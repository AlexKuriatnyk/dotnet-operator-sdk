<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Webhooks </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Webhooks ">
    <meta name="generator" content="docfx 2.56.6.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="webhooks">Webhooks</h1>

<p>Kubernetes supports various webhooks to extend the normal api behaviour
of the master api. Those are documented on the 
<a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">kubernetes website</a>.</p>
<p><code>KubeOps</code> supports the following webhooks out of the box:</p>
<ul>
<li>Validator / Validation</li>
</ul>
<p>The following documentation should give the user an overview
on how to implement a webhook what this implies to the written operator.</p>
<h2 id="general">General</h2>
<p>In general, if your operator contains <em>any</em> registered (registered in the
DI) the build process that is provided via <code>KubeOps.targets</code> will
generate a CA certificate for you.</p>
<p>So if you add a webhook to your operator the following changes
to the normal deployment of the operator will happen:</p>
<ol>
<li>During &quot;after build&quot; phase, the sdk will generate
a CA-certificate for self signed certificates for you.</li>
<li>The ca certificate and the corresponding key are added
to the deployment via kustomization config.</li>
<li>A special config is added to the deployment via
kustomization to use https.</li>
<li>The deployment of the operator now contains an <code>init-container</code>
that loads the <code>ca.pem</code> and <code>ca-key.pem</code> files and creates
a server certificate. Also, a service and the corresponding
webhook configurations are created.</li>
<li>When the operator starts, an additional https route is registered
with the created server certificate.</li>
</ol>
<p>When a webhook is registered, the specified operations will
trigger a POST call to the operator.</p>
<div class="NOTE"><h5>Note</h5><p>Make sure you commit the <code>ca.pem</code> / <code>ca-key.pem</code> file.
During operator startup (init container) those files
are needed. Since this represents a self signed certificate,
and it is only used for cluster internal communication,
it is no security issue to the system. The service is not
exposed to the internet.</p>
</div>
<div class="NOTE"><h5>Note</h5><p>The <code>server.pem</code> and <code>server-key.pem</code> files are generated
in the init container during pod startup.
Each pod / instance of the operator gets its own server
certificate but the CA must be shared among them.</p>
</div>
<h2 id="local-development">Local development</h2>
<p>It is possible to test webhooks locally. For this, you need
to register the webhook via dependency injection with the corresponding
method (in the builder) and then start your operator.</p>
<p>The operator will run on a specific http address, depending on your
configuration.
Now, use <a href="https://ngrok.com/">ngrok</a> or
<a href="https://localtunnel.github.io/www/">localtunnel</a> or something
similar to create a HTTPS tunnel to your local running operator.</p>
<p>Now you can use the cli command of the sdk
<code>dotnet run -- webhooks register --base-url &lt;&lt;TUNNEL URL&gt;&gt;</code> to
register the webhooks under the tunnel&#39;s url.</p>
<p>The result is your webhook being called by the kubernetes api.
It is suggested one uses <code>Docker Desktop</code> with kubernetes.</p>
<h2 id="validation-webhook">Validation webhook</h2>
<p>The general idea of this webhook type is to validate an entity
before it is definitely created / updated or deleted.</p>
<p>The implementation of a webhook is fairly simple:</p>
<ul>
<li>Create a class somewhere in your project.</li>
<li>Implement the <code>IValidationWebhook{TEntity}</code> interface.</li>
<li>Define the <code>Operations</code> (from the interface) that the validator
is interested in.</li>
<li>Overwrite the corresponding methods.</li>
<li>Register it in the <code>IOperatorBuilder</code> with <code>AddValidationWebhook</code>.</li>
</ul>
<div class="WARNING"><h5>Warning</h5><p>The interface contains default implementations for <em>ALL</em> methods.
The default of the async methods are to call the sync ones.
The default of the sync methods is to return a &quot;not implemented&quot;
result.
The async methods take precedence over the synchronous ones.</p>
</div>
<p>The return value of the validation methods are <code>ValidationResult</code>
objects. A result contains a boolean flag if the entity / operation
is valid or not. It may contain additional warnings (if it is valid)
that are presented to the user if the kubernetes api supports it.
If the result is invalid, one may add a custom http status code
as well as a custom error message that is presented to the user.</p>
<h3 id="example">Example</h3>
<pre><code class="lang-c#">public class TestValidator : IValidationWebhook&lt;V2TestEntity&gt;
 {
     public ValidatedOperations Operations =&gt; ValidatedOperations.Create | ValidatedOperations.Update;

     public ValidationResult Create(V2TestEntity newEntity, bool dryRun) =&gt;
         CheckSpec(newEntity)
             ? ValidationResult.Success(&quot;The username may not be foobar.&quot;)
             : ValidationResult.Fail(StatusCodes.Status400BadRequest, @&quot;Username is &quot;&quot;foobar&quot;&quot;.&quot;);

     public ValidationResult Update(V2TestEntity _, V2TestEntity newEntity, bool dryRun) =&gt;
         CheckSpec(newEntity)
             ? ValidationResult.Success(&quot;The username may not be foobar.&quot;)
             : ValidationResult.Fail(StatusCodes.Status400BadRequest, @&quot;Username is &quot;&quot;foobar&quot;&quot;.&quot;);

     private static bool CheckSpec(V2TestEntity entity) =&gt; entity.Spec.Username != &quot;foobar&quot;;
 }
</code></pre><p>And then register the webhook in <code>Startup.cs</code>:</p>
<pre><code class="lang-c#">public void ConfigureServices(IServiceCollection services)
{
    services
        .AddKubernetesOperator()
        // ...
        .AddValidationWebhook&lt;TestValidator&gt;();
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/buehler/dotnet-operator-sdk/blob/master/docs/docs/webhooks.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
